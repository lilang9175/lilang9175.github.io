<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试博客</category>
      </categories>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2024/08/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/%25E5%25BE%25AE%25E4%25BF%25A1%25E5%259B%25BE%25E7%2589%2587_20240807155858.jpg"></p>
]]></content>
      <categories>
        <category>测试博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络--基础篇</title>
    <url>/2024/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="计网基础篇"><a href="#计网基础篇" class="headerlink" title="计网基础篇"></a>计网基础篇</h1><h2 id="TCP-IP-网络模型有几层"><a href="#TCP-IP-网络模型有几层" class="headerlink" title="TCP&#x2F;IP 网络模型有几层"></a>TCP&#x2F;IP 网络模型有几层</h2><h3 id="为什么要有-TCP-IP-网络模型？"><a href="#为什么要有-TCP-IP-网络模型？" class="headerlink" title="为什么要有 TCP&#x2F;IP 网络模型？"></a>为什么要有 TCP&#x2F;IP 网络模型？</h3><p>​	对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。</p>
<h3 id="主要分为那几层？"><a href="#主要分为那几层？" class="headerlink" title="主要分为那几层？"></a>主要分为那几层？</h3><ul>
<li><strong>应用层</strong></li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong> </li>
<li><strong>网络接口层</strong></li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>我们能直接接触到的就是<strong>应用层</strong>，我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</li>
<li><strong>应用层</strong>只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</li>
<li><strong>应用层</strong>是工作在操作系统中的用户态，传输层及以下则工作在内核态。</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul>
<li><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p>
</li>
<li><p>在<strong>传输层</strong>会有两个传输协议，分别是 <strong>TCP</strong> 和 <strong>UDP</strong>。</p>
</li>
<li><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 <strong>TCP</strong> 传输层协议，比如 HTTP 应用层协议。<strong>TCP</strong> 相比 <strong>UDP</strong> 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>
</li>
<li><p><strong>UDP</strong> 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。</p>
</li>
<li><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 <strong>MSS</strong>（<strong>TCP</strong> 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 <strong>TCP</strong> 协议中，我们把每个分块称为一个 <strong>TCP 段</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808113532671.png" alt="image-20240808113532671"></p>
</li>
<li><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p>
</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li><p><strong>网络层</strong>（<em>Internet Layer</em>）负责将数据从一个设备传输到另一个设备。</p>
</li>
<li><p>网络层最常使用的是 <strong>IP 协议</strong>（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808150221325.png" alt="image-20240808150221325"></p>
</li>
<li><p>网络层需要有区分设备的编号。因此，需要将 IP 地址分成两种意义：</p>
<ul>
<li><p>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</p>
</li>
<li><p>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</p>
</li>
<li><p>使用<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号：</p>
<ul>
<li><p>将 <strong>子网掩码</strong>与<strong>IP地址</strong>进行<strong>按位与运算</strong>，就可以得到网络号 如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808150041754.png" alt="image-20240808150041754"></p>
</li>
<li><p>将 <strong>子网掩码</strong>取反后与<strong>IP地址</strong>进行<strong>按位与运算</strong>，就可以得到主机号。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP 协议有两个重要的能力就是<strong>路由</strong>与<strong>寻址</strong>：</p>
<ul>
<li>实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</li>
<li>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808150658163.png" alt="image-20240808150658163"></p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><ul>
<li>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</li>
<li>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上，IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</li>
</ul>
<h3 id="总体示意图"><a href="#总体示意图" class="headerlink" title="总体示意图"></a>总体示意图</h3><ul>
<li><p>TCP&#x2F;IP 网络模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808151349285.png" alt="image-20240808151349285"></p>
</li>
<li><p>每一层的封装格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808151420924.png" alt="image-20240808151420924"></p>
</li>
<li><p>网络接口层的传输单位是<strong>帧</strong>（frame），IP 层的传输单位是<strong>包</strong>（packet），TCP 层的传输单位是<strong>段</strong>（segment），HTTP 的传输单位则是<strong>消息</strong>或<strong>报文</strong>（message）。但这些名词并没有什么本质的区分，可以统称为<strong>数据包</strong>。</p>
</li>
</ul>
<h2 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h2><h3 id="1-浏览器做的第一步工作是解析-URL"><a href="#1-浏览器做的第一步工作是解析-URL" class="headerlink" title="1.浏览器做的第一步工作是解析 URL"></a>1.浏览器做的第一步工作是解析 URL</h3><ul>
<li><p>浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息</p>
</li>
<li><p>如下图所示 <code>URL</code> 表示什么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808152405691.png" alt="image-20240808152405691"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808152432075.png" alt="image-20240808152432075"></p>
</li>
<li><p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p>
<ul>
<li><p>请求报文</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808152633029.png" alt="image-20240808152633029"></p>
</li>
<li><p>响应报文</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808152655980.png" alt="image-20240808152655980"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-真实地址查询-——-DNS"><a href="#2-真实地址查询-——-DNS" class="headerlink" title="2.真实地址查询 —— DNS"></a>2.真实地址查询 —— DNS</h3><ul>
<li><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。前提是要<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p>
</li>
<li><p>服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。类似于电话号 + 姓名保存在通讯录里。</p>
</li>
<li><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
</li>
<li><p>所以域名的层级关系类似一个树状结构，例如<code>www.server.com.</code>：</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808153448469.png" alt="image-20240808153448469"></p>
</li>
<li><p>域名解析的工作流程:</p>
<ul>
<li><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p>
</li>
<li><p>客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808153620362.png" alt="image-20240808153620362"></p>
</li>
</ul>
</li>
<li><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
</li>
</ul>
<h3 id="3-指南好帮手-——-协议栈"><a href="#3-指南好帮手-——-协议栈" class="headerlink" title="3.指南好帮手 —— 协议栈"></a>3.指南好帮手 —— 协议栈</h3><ul>
<li><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808154137862.png" alt="image-20240808154137862"></p>
</li>
<li><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p>
</li>
<li><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808154120740.png" alt="image-20240808154120740"></p>
</li>
<li><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p>
<ul>
<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>
<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>
</ul>
</li>
</ul>
<h3 id="4-可靠传输-——-TCP"><a href="#4-可靠传输-——-TCP" class="headerlink" title="4.可靠传输 —— TCP"></a>4.可靠传输 —— TCP</h3><ul>
<li><p>HTTP 是基于 TCP 协议传输的</p>
</li>
<li><p>TCP 报文头部的格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808160431342.png" alt="image-20240808160431342"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808160457509.png" alt="image-20240808160457509"></p>
<ul>
<li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li>
<li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li>
<li>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题</li>
<li>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li>
<li>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</li>
<li>TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。</li>
</ul>
</li>
<li><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808160736049.png" alt="image-20240808160736049"></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>
<li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li>
<li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li>
<li><strong>所以三次握手目的是保证双方都有发送和接收的能力</strong>。</li>
</ul>
</li>
<li><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808161105301.png" alt="image-20240808161105301"></p>
</li>
<li><p><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</p>
</li>
<li><p><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</p>
</li>
<li><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）。</p>
</li>
<li><p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理</p>
</li>
</ul>
<h3 id="5-远程定位-——-IP"><a href="#5-远程定位-——-IP" class="headerlink" title="5.远程定位 —— IP"></a>5.远程定位 —— IP</h3><ul>
<li><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p>
</li>
<li><p>IP 报文头部的格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808161505089.png" alt="image-20240808161505089"></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808161532140.png" alt="image-20240808161532140"></p>
<ul>
<li><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p>
<ul>
<li>源地址IP，即是客户端输出的 IP 地址；</li>
<li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li>
</ul>
</li>
<li><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p>
</li>
</ul>
<blockquote>
<p>当存在多个网卡时，在填写源地址 IP 时,就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808161945695.png" alt="image-20240808161945695"></p>
<ul>
<li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li>
<li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li>
<li>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</li>
</ul>
<h3 id="6-两点传输-——-MAC"><a href="#6-两点传输-——-MAC" class="headerlink" title="6.两点传输 —— MAC"></a>6.两点传输 —— MAC</h3><ul>
<li><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p>
</li>
<li><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息:</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808162147385.png" alt="image-20240808162147385"></p>
</li>
<li><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p>
<p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p>
<ul>
<li><code>0800</code> ： IP 协议</li>
<li><code>0806</code> ： ARP 协议</li>
</ul>
</li>
<li><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了</p>
</li>
<li><p><strong>接收方</strong>的 MAC 地址获取,先查一下<strong>路由表</strong>，在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备，帮我们找到路由器的 MAC 地址。</p>
<ul>
<li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li>
<li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询</li>
</ul>
</li>
</ul>
<h3 id="7-出口-——-网卡"><a href="#7-出口-——-网卡" class="headerlink" title="7. 出口 —— 网卡"></a>7. 出口 —— 网卡</h3><ul>
<li><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
</li>
<li><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p>
</li>
<li><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808162838750.png" alt="image-20240808162838750"></p>
<ul>
<li>起始帧分界符是一个用来表示包起始位置的标记</li>
<li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li>
</ul>
</li>
<li><p>最后网卡会将包转为电信号，通过网线发送出去。</p>
</li>
</ul>
<h3 id="8-交换机与路由器"><a href="#8-交换机与路由器" class="headerlink" title="8.交换机与路由器"></a>8.交换机与路由器</h3><ul>
<li><p>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</p>
<ul>
<li>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</li>
<li>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</li>
<li>路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</li>
<li><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。查询<strong>路由表</strong>判断转发目标IP地址，之后通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</li>
</ul>
</li>
<li><p>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<ul>
<li>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层</li>
<li>交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</li>
<li>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</li>
<li>交换机的 MAC 地址表主要包含两个信息：<ul>
<li>一个是设备的 MAC 地址，</li>
<li>另一个是该设备连接在交换机的哪个端口上。</li>
</ul>
</li>
</ul>
<ul>
<li>如果地址表中找不到指定的 MAC 地址。交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</li>
</ul>
</li>
</ul>
<ul>
<li>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</li>
</ul>
<h3 id="9-服务器-与-客户端"><a href="#9-服务器-与-客户端" class="headerlink" title="9.服务器 与 客户端"></a>9.服务器 与 客户端</h3><ul>
<li><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
</li>
<li><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
</li>
<li><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>
</li>
<li><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>
</li>
<li><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
</li>
<li><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
</li>
<li><p>图解如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lilang9175/myblog@main/img/image-20240808164336007.png" alt="image-20240808164336007"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
